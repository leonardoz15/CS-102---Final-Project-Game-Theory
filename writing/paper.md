# Chris Cook, Andrew Everitt, Simon Burrows & Zachary Leonardo (Team Nondiscrete Chaos)
# Computer Science 102 Discrete Structures Fall 2018
# Honor Code: This work is ours and solely ours unless otherwise cited.

  Game Theory is a series of mathematical concepts that show different strategies for decision making. The idea of game theory was first brought about by John von Neumann with his Brouwer fixed-point theorem. His discovery led to the foundation for game theory and was a major inspiration for mathematical economics. For our final project, we decided to research game theory and use our knowledge from the class to create a program that allowed the user to play the game Nim. 
  According to an article published by the IT University of Copenhagen, games similar to Nim can be found as far back as ancient times, but many believe that it can be traced to China. Although variations of the game have existed for centuries, a formal proof wasn’t released until 1901, when Charles L. Bouton of Harvard published the solution for Nim in the journal Annals of Mathematics; an event that marked the birth of game theory. In Nim, players take turns removing pieces from several piles. Players can pick any pile and may remove as many pieces as they would like. The player that makes the last move, thus leaving no moves for their opponent to make, wins. However, Nim can be played in two ways. The aforementioned goal is considered the normal variety. The misère way gives the victory to the person who cannot make a move; essentially the opposite of the normal way. 
	As previously stated, the game ends when there are no moves for a player to make. Given the number of piles and size of each one, the “exclusive or” logic gate can be used to determine the winner. The output of this algorithm performed across all piles is called the “nim sum.” If the nim sum is equal to zero at the start of the game, the second player should win given best play. If the nim sum is equal to anything other than zero, the winning strategy is to reduce it to zero through a binary balancing method. The premise of the method is to convert the size of each pile to binary and add up each column without carrying. If the result is zero the column is balanced. All unbalanced columns will need to be modified to a balanced position by the players move. The nim sum will always be able to be reduced to zero in a single move. In our program, the computer makes this move through a trial and error method but is still efficient.
	Our program serves as a way to play Nim, but also includes methods which determine who will win through calculating the nim sum. After the program starts, it asks the user how many piles they would like to play with as well as the value for each pile. Once this information has been entered, a method calculates the nim sum, which is then used to predict who will win the game. In our version, the human always plays first. The program asks the user what pile they would like to remove from and how many they will remove. The piles’ values are stored in a list, which is updated once the program checks to make sure that the pile exists and has a value greater than or equal to that of the value entered by the user. Next, the new pile sizes are printed and the program checks the nim sum. If the nim sum is already zero, the computer will remove one from the first non-empty pile due to the fact that it thinks that it will lose the game. On the other hand, if the nim sum isn’t zero it will remove chips from each pile and calculate the nim sum recursively until finding the correct move. The process of the human and computer alternating turns continues until there are no moves remaining. 
	Over the years game theory has gained more of a significant role in the computer science field. Game theory has strong ties to computer science as it can involve binary arithmetic and logic. Computer science logic also goes along well with game semantics, as it requires justification for some concepts within game theory. Computer scientists have used game concepts in many real-world applications. Some examples of game theory in applications are included in fields like cloud computing, machine learning, and network security. All of these areas of computer science require interaction with the outside world while computations is taking place. The code for our Nim program includes the use of the XOR (exclusive or), which is used to carry out the nim sum calculation. In the end, game theory and computer science work hand in hand because of the intersections between each of their principles. 
	During the group meetings, we utilized the Atom package “Teletype” in order to simultaneously work on different aspects of the code. Furthermore, we each tried to work on facets of the project we felt the most comfortable with. For example, Andrew worked on the main, play, and parts of the computer method. It was completed by Zach and Simon who were able to use their pre-existing knowledge of the XOR operation for the computer’s move when it has a chance to win. After we had a strong foundation for the program, we tested it and made corrections in response to the error messages. This practice isn’t the best approach for large projects, but we felt confident given our knowledge of Python and Nim as well as the communication amongst ourselves. Once the game was able to run, we only had to fix a small number of gameplay related bugs of special cases to complete the code. 
	Overall, the implementation of the project went well. We did not encounter a plethora of challenges while coding due to our existing knowledge on the subject as well as good communication within our group. The hardest part of the process was trying to make the method for the computer’s move simple and efficient. Originally, we looked at calculating the binary values for all of the piles but realized that this could be inefficient if the user created a large number of piles or assigned a large number of chips to each pile. We then found a solution using a while loop with for, if, and else statements. The computer moves through each pile and calculates the nim sum after its potential move and if can be reduced to zero, it will make the move accordingly. In its final state, the project is able to predict the outcome and provide a fully playable version of Nim. Given more time, we would have liked to implement the ability to let the user view the rules in the program itself instead of opening the README, expand on the computer’s moves (possibly code random move generator so that it is still possible to win if the user makes a mistake), add further restrictions when entering the specifics so that the user must make a winnable game (in addition to no single pile games or games with piles of zero), and add an option to play a game with two human or computer players. 
